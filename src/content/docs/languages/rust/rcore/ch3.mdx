---
title: "第三章"
---

## 批处理多任务管理

### 多道程序放置与加载

首先给不同 app 设置不同的 BASE_ADDRESS，运行操作系统内核时就可以同时把所有 app 都加载进内存了

### 任务管理与任务切换

内核中维护一个任务管理器，他维护任务状态：`未初始化`、`准备运行`、`正在运行`、`已退出`，以及所有任务的任务状态、各任务保存的寄存器上下文，和当前内核正在执行的任务

通过 `sys_yield` 这个系统调用，在这个系统调用将 cpu trap 到 S Mode 时，内核会保存当前任务寄存器上下文，设置当前任务状态为 `准备运行`，然后将下一个任务的寄存器上下文弹出，设置任务状态为 `正在运行`，并设置当前任务为该任务

### 协作式调度

即用户应用程序主动调用 sys_yield，主动 suspend 自己，等待操作系统下次再执行这个 task（教程里本章处理方式是执行下一个任务，然后剩余任务里也会主动调用 sys_yield）

### 分时多任务与抢占式调度

协作式调度是应用不主动 yield 交出 CPU 使用权就会一直执行下去，抢占式调度是应用随时都有被内核切换出去的可能

现代的任务调度算法基本都是抢占式的，它要求每个应用只能连续执行一段时间，然后内核就会将它强制性切换出去。一般将 时间片 (Time Slice) 作为应用连续执行时长的度量单位，每个时间片可能在毫秒量级。调度算法需要考虑：每次在换出之前给一个应用多少时间片去执行，以及要换入哪个应用。可以从性能（主要是吞吐量和延迟两个指标）和 公平性 (Fairness) 两个维度来评价调度算法，后者要求多个应用分到的时间片占比不应差距过大。

### Linux 内核浏览器网站

https://elixir.bootlin.com
